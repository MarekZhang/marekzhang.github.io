{"categories":[{"title":"Other","uri":"https://marekzhang.github.io/categories/other/"},{"title":"Redis","uri":"https://marekzhang.github.io/categories/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/categories/spring-boot/"}],"posts":[{"content":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到新订单的提醒。既然是发送即时通知，使用Web Socket是一个比较好的解决方案\n  首先引入Maven Dependency\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;    配置一个ServerEndpointExporter 这一步很关键。通常情况下Tomcat会主动使用ServletContainerInitializer扫描带有@ServerEndpoint注解的类，但是Spring-Boot这种内嵌web container的框架并不会执行这一步。如果忽略掉这一步配置就会是无尽的404\u0026hellip;\n@Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } }    后台订单页面引入Web Socket js部分。首先判断当前浏览器是否支持Web Socket，之后对onopen(web socekt建立链接), onclose(断开web socket), onerror(web socket链接错误), onmessage(web socket接收到新信息) 以及onbeforunload(页面重新加载前对操作)进行设置。\nvar webSocket = null; if('WebSocket' in window){ webSocket = new WebSocket('ws://markzhang.natapp1.cc/sell/webSocket'); }else{ alert(\u0026quot;current browser does not support web socket\u0026quot;); } webSocket.onopen = function(event){ console.log(\u0026quot;connection set up\u0026quot;); } webSocket.onclose = function(event){ console.log(\u0026quot;web socket disconnected\u0026quot;); }; webSocket.onerror = function(event){ alert(\u0026quot;web socket connection error\u0026quot;); }; webSocket.onmessage = function(event){ console.log(\u0026quot;new message received: \u0026quot; + event.data); $('#orderAlert').modal('show'); document.getElementById('altertAudio').play(); $('#orderDetail').on(\u0026quot;click\u0026quot;, function(){ location.href=\u0026quot;/sell/vendor/order/detail?orderId=\u0026quot;+event.data; }); }; window.onbeforeunload = function(event){ webSocket.close(); };    后台中@ServerEndpoint用来设置web socket 链接的地址。同样对onOpen, onClose, onMessage事件设置响应的程序。这里后端的@onMessage部分不要与前端页面的webSocket.onmessage搞混。@onMessage是前端页面向后端发送信息后端的响应。而webSocket.onmessage是后台有新下单事件发生，后台通过broadcast方法向前端页面发送信息后前端作出的反应。\n  @Component @Slf4j @ServerEndpoint(\u0026quot;/webSocket\u0026quot;) public class WebSocket { private Session session; /** * thread safe set */ private static Set\u0026lt;WebSocket\u0026gt; listeners = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); @OnOpen public void onOpen(Session session) { this.session = session; listeners.add(this); log.info(\u0026quot;[web socket message] set up a connection, number of connections: {}\u0026quot;, listeners.size()); } @OnClose public void onClose(Session session) { listeners.remove(this); log.info(\u0026quot;[web socket message] close a connection, number of connections: {}\u0026quot;, listeners.size()); } /** * server side receive message from the client side * @param message */ @OnMessage public void onMessage(String message) { log.info(\u0026quot;[web socket message] receive message from the client side={}\u0026quot;, message); } /** * server broadcast message to front end sockets * @param message */ public void broadcast(String message) { for (WebSocket listener : listeners) { log.info(\u0026quot;[web socket message] broadcast message={}\u0026quot;, message); try { listener.session.getBasicRemote().sendText(message); } catch (IOException e) { log.error(\u0026quot;[web socket message] broadcast message error: {}\u0026quot;, e.getMessage()); } } } }  这样接单的前台html就和后端打通了，只需要在service层中，下单之后调用boradcast方法就可以发送即时消息了。 //4. revise the number of stock List\u0026lt;CartDTO\u0026gt; cartDTOS = orderDTO.getOrderDetailList().stream(). map(e -\u0026gt; new CartDTO(e.getProductId(), e.getProductQuantity())).collect(Collectors.toList()); productInfoService.decreaseStock(cartDTOS); //5. send message to web socket webSocket.broadcast(orderDTO.getOrderId());    Presentation ","id":0,"section":"posts","summary":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到","tags":["WebSocket","Java","Spring Boot"],"title":"WebSocket in Spring Boot","uri":"https://marekzhang.github.io/2020/09/websocket-spring-boot/","year":"2020"},{"content":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","id":1,"section":"posts","summary":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","tags":["Hugo","Pitfalls"],"title":"Hugo Pitfall","uri":"https://marekzhang.github.io/2020/09/hugo-pitfalls/","year":"2020"},{"content":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存和订单部分数据，在高并发的场景下就会产生超卖的问题。\npublic void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Solution  最简单的解决办法是在函数上加synchronize关键字。但会带来几个问题：  运行时间慢：synchronize本质上把线程推入到一个队列中，按照单线程的逻辑运行每一个线程 如果系统被做成了cluster，那么还是会有问题。线程在不同node中运行得到的结果还是不一样    public synchronize void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Apache ab 压测\n ab -n500 -c100 http://127.0.0.1:8080/sell/skill/order/123456    使用Redis SETNX 和 GETSET两个命令就可以组合出一个简单的distributed lock，用以解决高并发引入的问题\n SETNX Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed.\u0026gt; SETNX is short for \u0026ldquo;SET if Not eXists\u0026rdquo;.\n  GETSET Atomically sets key to value and returns the old value stored at key. Returns an error when key exists but does not hold a string value.   线程使用SETNX对资源进行加锁，如果加锁成功则当前线程获得了资源的使用权。(key:当前资源标识 value: 锁的过期时间（解决死锁问题）) 如果加锁失败，有两种情况: 当前系统资源已经被其他线程占用; 上一个线程出现了异常但没有对锁进行释放). 此时应该先用GET方法取出Value值，如果过期则需要使用GETSET方法对Key进行重新设置，如果GETSET方法返回值与过期的VALUE值相同，证明当前线程成功获得了锁，如果不同则证明同一时间有其他线程进行了相同的操作并获得了锁。如果未过期返回false  @Service(\u0026quot;RedisLock\u0026quot;) public class RedisLock { @Autowired StringRedisTemplate stringRedisTemplate; /** * lock * @param key productId * @param value currentTime + timeout * @return */ public boolean lock(String key, String value) { //current thread get the lock if (stringRedisTemplate.opsForValue().setIfAbsent(key, value)) { return true; } //check if the lock is expired String currentValue = stringRedisTemplate.opsForValue().get(key); //lock is expired if (currentValue != null \u0026amp;\u0026amp; currentValue.length() != 0 \u0026amp;\u0026amp; Long.parseLong(currentValue) \u0026lt; System.currentTimeMillis()) { String oldValue = stringRedisTemplate.opsForValue().getAndSet(key, value); //current thread get the lock if (oldValue!=null \u0026amp;\u0026amp; oldValue.length() != 0 \u0026amp;\u0026amp; currentValue.equals(oldValue)) return true; } return false; } /** * unlock * @param key productId */ public void unlock(String key) { String value = stringRedisTemplate.opsForValue().get(key); if (value != null \u0026amp;\u0026amp; value.length() != 0) { stringRedisTemplate.delete(key); } } }    ","id":2,"section":"posts","summary":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存","tags":["Java","Redis","Spring Boot"],"title":"Redis distributed lock","uri":"https://marekzhang.github.io/2020/09/redis-distributed-lock/","year":"2020"}],"tags":[{"title":"Hugo","uri":"https://marekzhang.github.io/tags/hugo/"},{"title":"Java","uri":"https://marekzhang.github.io/tags/java/"},{"title":"Pitfalls","uri":"https://marekzhang.github.io/tags/pitfalls/"},{"title":"Redis","uri":"https://marekzhang.github.io/tags/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/tags/spring-boot/"},{"title":"WebSocket","uri":"https://marekzhang.github.io/tags/websocket/"}]}