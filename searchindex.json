{"categories":[{"title":"Algorithms","uri":"https://marekzhang.github.io/categories/algorithms/"},{"title":"Java","uri":"https://marekzhang.github.io/categories/java/"},{"title":"Other","uri":"https://marekzhang.github.io/categories/other/"},{"title":"Redis","uri":"https://marekzhang.github.io/categories/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/categories/spring-boot/"}],"posts":[{"content":"Description  142. Linked List Cycle II\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally,\npos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nNotice that you should not modify the linked list.\nFollow up:\nCan you solve it using O(1) (i.e. constant) memory?  Solution  使用fast slow pointers，如果两个指针不能相遇 return null 如果两个指针相遇，相遇的位置为 C % F, C为环的结点个数，F为head到intersection point的结点个数 相遇后slow pointer退回到起始点，fast移动到下一个结点。之后fast slow pointers每次移动一个位置，两个指针再次相遇的位置即为intersection point  public class Solution { //time complexity O(n) || space complexity O(1) public ListNode detectCycle(ListNode head) { if(head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head.next; while(fast != null \u0026amp;\u0026amp; fast.next != null){ if(fast == slow){ slow = head; fast = fast.next; while(fast != slow){ fast = fast.next; slow = slow.next; } return fast; } fast = fast.next.next; slow = slow.next; } return null; } }  ","id":0,"section":"posts","summary":"Description 142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note","tags":null,"title":"Leetcode 142 Linked List Cycle II","uri":"https://marekzhang.github.io/2020/09/linked-list-cycle-ii/","year":"2020"},{"content":"Description  92. Reverse Linked List II\nReverse a linked list from position m to n. Do it in one-pass.\nNote: 1 ≤ m ≤ n ≤ length of list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL\n Solution  需要使用DummyHead，因为反转的起始点可能是第一个元素 使用双指针确定反转的区间，找到idx m 前一个元素和 idx n后一个元素 反转LinkedList可以将nex指针初始值赋为cur，这样每次反转之前先挪动nex到下一个位置，就不用考虑cur为null，移动nex所产生的NullPointerException了  class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if(m == n) return head; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode slow = dummyHead; ListNode fast = dummyHead; //find the prev position of m and nex position of n for(int i = 0; i \u0026lt;= n - m + 1; i++ ) fast = fast.next; for(int i = 1; i \u0026lt; m; i++){ slow = slow.next; fast = fast.next; } ListNode cur = slow.next; ListNode nex = cur; ListNode prev = fast; while(cur != fast){ nex = cur.next; cur.next = prev; prev = cur; cur = nex; } slow.next = prev; return dummyHead.next; } }  ","id":1,"section":"posts","summary":"Description 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL Solution 需要使用DummyHead，因为反转的起始点可能是第一个元素","tags":null,"title":"Leetcode 92. Reverse Linked List II","uri":"https://marekzhang.github.io/2020/09/reverse-linked-list-ii/","year":"2020"},{"content":"Generic Method  如果可以使用泛型方法来替代整个类的泛型化就应该使用泛型方法 static方法无法访问泛型类的类型参数，所有static方法需要使用泛型能力就必须称为泛型方法  public class GenericMethods{ public \u0026lt;T\u0026gt; void f(T x){ System.out.println(x.getClass().getName()); } }   使用泛型方法时不必知名参数类型，因为编译器会找出具体类型 \u0026ndash; type argument inference\n Generic Type and Wildcard \u0026lt;?\u0026gt;  用来声明一个泛型方法或者泛型类。 通配符\u0026lt;?\u0026gt; 使用泛型类或者泛型方法  Type Erasure 考虑下面的情况,返回的结果为true。\npublic class ErasedTypeEquivalence{ public static void main(String[] args){ Class c1 = new ArrayList\u0026lt;String\u0026gt;().getClass(); Class c2 = new ArrayList\u0026lt;Integer\u0026gt;().getClass(); System.out.println(c1 == c2); //true } }   在泛型代码内部，无法获得任何有关泛型类型参数类型的信息\nMap\u0026lt;Long, Double\u0026gt; p = new HashMap\u0026lt;\u0026gt;(); System.out.println(p.getClass().getTypeParameters); //[K, V]    如下代码不能编译\npublic class HasF { public void f() { System.out.println(\u0026quot;HasF.f()\u0026quot;); } } class Manipulator\u0026lt;T\u0026gt; { private T obj; public Manipulator (T x) { obj = x; } public void manipulate() { obj.f(); } //compilation error } public class Manipulation { public static void main(String[] args) { HasF hf = new HasF(); Manipulator\u0026lt;HasF\u0026gt; manipulator = new Manipulator\u0026lt;\u0026gt;(); manipulator.manipulate(); } }  由于擦除机制，Java编译器无法将manipulate()方法在obj上调用f()与HasF拥有f()这一事实映射起来\n  修改Manipulator类为,泛型擦除会将类擦除到第一边界HasF\nclass Manipulator\u0026lt;T extends HasF\u0026gt;  泛型擦除机制的引入是为了兼容Java SE5之前的代码\n ","id":2,"section":"posts","summary":"Generic Method 如果可以使用泛型方法来替代整个类的泛型化就应该使用泛型方法 static方法无法访问泛型类的类型参数，所有static方法需要使用泛型能力","tags":["Java"],"title":"Java Generics","uri":"https://marekzhang.github.io/2020/09/java-generics/","year":"2020"},{"content":"ArrayList  public E remove(int index)  public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }  remove 移除index位置的元素: 首先计算index后面有多少个元素（numMoved），如果元素个数多于1个，使用arrayCopy将index后面所有元素整体向前移动一位\n","id":3,"section":"posts","summary":"ArrayList public E remove(int index) public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } remove 移除index位置的元素: 首先计算index","tags":["Reading Source Code"],"title":"ArrayList Source Code","uri":"https://marekzhang.github.io/2020/09/arraylist/","year":"2020"},{"content":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到新订单的提醒。既然是发送即时通知，使用Web Socket是一个比较好的解决方案\n  首先引入Maven Dependency\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;    配置一个ServerEndpointExporter 这一步很关键。通常情况下Tomcat会主动使用ServletContainerInitializer扫描带有@ServerEndpoint注解的类，但是Spring-Boot这种内嵌web container的框架并不会执行这一步。如果忽略掉这一步配置就会是无尽的404\u0026hellip;\n@Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } }    后台订单页面引入Web Socket js部分。首先判断当前浏览器是否支持Web Socket，之后对onopen(web socekt建立链接), onclose(断开web socket), onerror(web socket链接错误), onmessage(web socket接收到新信息) 以及onbeforunload(页面重新加载前对操作)进行设置。\nvar webSocket = null; if('WebSocket' in window){ webSocket = new WebSocket('ws://markzhang.natapp1.cc/sell/webSocket'); }else{ alert(\u0026quot;current browser does not support web socket\u0026quot;); } webSocket.onopen = function(event){ console.log(\u0026quot;connection set up\u0026quot;); } webSocket.onclose = function(event){ console.log(\u0026quot;web socket disconnected\u0026quot;); }; webSocket.onerror = function(event){ alert(\u0026quot;web socket connection error\u0026quot;); }; webSocket.onmessage = function(event){ console.log(\u0026quot;new message received: \u0026quot; + event.data); $('#orderAlert').modal('show'); document.getElementById('altertAudio').play(); $('#orderDetail').on(\u0026quot;click\u0026quot;, function(){ location.href=\u0026quot;/sell/vendor/order/detail?orderId=\u0026quot;+event.data; }); }; window.onbeforeunload = function(event){ webSocket.close(); };    后台中@ServerEndpoint用来设置web socket 链接的地址。同样对onOpen, onClose, onMessage事件设置响应的程序。这里后端的@onMessage部分不要与前端页面的webSocket.onmessage搞混。@onMessage是前端页面向后端发送信息后端的响应。而webSocket.onmessage是后台有新下单事件发生，后台通过broadcast方法向前端页面发送信息后前端作出的反应。\n  @Component @Slf4j @ServerEndpoint(\u0026quot;/webSocket\u0026quot;) public class WebSocket { private Session session; /** * thread safe set */ private static Set\u0026lt;WebSocket\u0026gt; listeners = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); @OnOpen public void onOpen(Session session) { this.session = session; listeners.add(this); log.info(\u0026quot;[web socket message] set up a connection, number of connections: {}\u0026quot;, listeners.size()); } @OnClose public void onClose(Session session) { listeners.remove(this); log.info(\u0026quot;[web socket message] close a connection, number of connections: {}\u0026quot;, listeners.size()); } /** * server side receive message from the client side * @param message */ @OnMessage public void onMessage(String message) { log.info(\u0026quot;[web socket message] receive message from the client side={}\u0026quot;, message); } /** * server broadcast message to front end sockets * @param message */ public void broadcast(String message) { for (WebSocket listener : listeners) { log.info(\u0026quot;[web socket message] broadcast message={}\u0026quot;, message); try { listener.session.getBasicRemote().sendText(message); } catch (IOException e) { log.error(\u0026quot;[web socket message] broadcast message error: {}\u0026quot;, e.getMessage()); } } } }  这样接单的前台html就和后端打通了，只需要在service层中，下单之后调用boradcast方法就可以发送即时消息了。 //4. revise the number of stock List\u0026lt;CartDTO\u0026gt; cartDTOS = orderDTO.getOrderDetailList().stream(). map(e -\u0026gt; new CartDTO(e.getProductId(), e.getProductQuantity())).collect(Collectors.toList()); productInfoService.decreaseStock(cartDTOS); //5. send message to web socket webSocket.broadcast(orderDTO.getOrderId());    Presentation ","id":4,"section":"posts","summary":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到","tags":["WebSocket","Java","Spring Boot"],"title":"WebSocket in Spring Boot","uri":"https://marekzhang.github.io/2020/09/websocket-spring-boot/","year":"2020"},{"content":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","id":5,"section":"posts","summary":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","tags":["Hugo","Pitfalls"],"title":"Hugo Pitfall","uri":"https://marekzhang.github.io/2020/09/hugo-pitfalls/","year":"2020"},{"content":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存和订单部分数据，在高并发的场景下就会产生超卖的问题。\npublic void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Solution  最简单的解决办法是在函数上加synchronize关键字。但会带来几个问题：  运行时间慢：synchronize本质上把线程推入到一个队列中，按照单线程的逻辑运行每一个线程 如果系统被做成了cluster，那么还是会有问题。线程在不同node中运行得到的结果还是不一样    public synchronize void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Apache ab 压测\n ab -n500 -c100 http://127.0.0.1:8080/sell/skill/order/123456    使用Redis SETNX 和 GETSET两个命令就可以组合出一个简单的distributed lock，用以解决高并发引入的问题\n SETNX Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed.\u0026gt; SETNX is short for \u0026ldquo;SET if Not eXists\u0026rdquo;.\n  GETSET Atomically sets key to value and returns the old value stored at key. Returns an error when key exists but does not hold a string value.\n  线程使用SETNX对资源进行加锁，如果加锁成功则当前线程获得了资源的使用权。(key:当前资源标识 value: 锁的过期时间（解决死锁问题）) 如果加锁失败，有两种情况: 当前系统资源已经被其他线程占用; 上一个线程出现了异常但没有对锁进行释放). 此时应该先用GET方法取出Value值，如果过期则需要使用GETSET方法对Key进行重新设置，如果GETSET方法返回值与过期的VALUE值相同，证明当前线程成功获得了锁，如果不同则证明同一时间有其他线程进行了相同的操作并获得了锁。如果未过期返回false  @Service(\u0026quot;RedisLock\u0026quot;) public class RedisLock { @Autowired StringRedisTemplate stringRedisTemplate; /** * lock * @param key productId * @param value currentTime + timeout * @return */ public boolean lock(String key, String value) { //current thread get the lock if (stringRedisTemplate.opsForValue().setIfAbsent(key, value)) { return true; } //check if the lock is expired String currentValue = stringRedisTemplate.opsForValue().get(key); //lock is expired if (currentValue != null \u0026amp;\u0026amp; currentValue.length() != 0 \u0026amp;\u0026amp; Long.parseLong(currentValue) \u0026lt; System.currentTimeMillis()) { String oldValue = stringRedisTemplate.opsForValue().getAndSet(key, value); //current thread get the lock if (oldValue!=null \u0026amp;\u0026amp; oldValue.length() != 0 \u0026amp;\u0026amp; currentValue.equals(oldValue)) return true; } return false; } /** * unlock * @param key productId */ public void unlock(String key) { String value = stringRedisTemplate.opsForValue().get(key); if (value != null \u0026amp;\u0026amp; value.length() != 0) { stringRedisTemplate.delete(key); } } }    ","id":6,"section":"posts","summary":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存","tags":["Java","Redis","Spring Boot"],"title":"Redis distributed lock","uri":"https://marekzhang.github.io/2020/09/redis-distributed-lock/","year":"2020"}],"tags":[{"title":"Hugo","uri":"https://marekzhang.github.io/tags/hugo/"},{"title":"Java","uri":"https://marekzhang.github.io/tags/java/"},{"title":"Pitfalls","uri":"https://marekzhang.github.io/tags/pitfalls/"},{"title":"Reading Source Code","uri":"https://marekzhang.github.io/tags/reading-source-code/"},{"title":"Redis","uri":"https://marekzhang.github.io/tags/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/tags/spring-boot/"},{"title":"WebSocket","uri":"https://marekzhang.github.io/tags/websocket/"}]}