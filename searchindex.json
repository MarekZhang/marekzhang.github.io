{"categories":[{"title":"Algorithms","uri":"https://marekzhang.github.io/categories/algorithms/"},{"title":"csapp","uri":"https://marekzhang.github.io/categories/csapp/"},{"title":"Java","uri":"https://marekzhang.github.io/categories/java/"},{"title":"Other","uri":"https://marekzhang.github.io/categories/other/"},{"title":"Redis","uri":"https://marekzhang.github.io/categories/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/categories/spring-boot/"}],"posts":[{"content":"33.Search in Rotated Sorted Array You are given an integer array nums sorted in ascending order, and an integer target.\nSuppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nIf target is found in the array return its index, otherwise, return -1.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Example 3:\nInput: nums = [1], target = 0 Output: -1\nConstraints:\n1 \u0026lt;= nums.length \u0026lt;= 5000 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 All values of nums are unique. nums is guranteed to be rotated at some pivot. -10^4 \u0026lt;= target \u0026lt;= 10^4\nSolution  nums is guranteed to be rotated at some pivot 使用binary search, 数组一定旋转过，且后半区域值小于前半区域  当target \u0026gt; nums[0]的时候要寻找的值在前半区  nums[mid] \u0026lt; target 可能落在了前半区也可能落在了后半区，因为后半区的值都小于nums[0],nums[0] \u0026lt; target;需要用nus[mid]与nums[0]作比较来确定区域进而调整left right位置 nums[mid] \u0026gt; target, 毫无疑问right = mid - 1；   当target \u0026lt; nums[0]的时候要寻找的值在后半区  nums[mid] \u0026gt; target 可能落在来前半区也可能落在来后半区，这时候需要比较nums[mid] 与 nums[0]作比较来确定区间 nums[mid] \u0026lt; target, 毫无疑问 left = mid + 1;      class Solution { //time O(logN) || space O(1) public int search(int[] nums, int target) { if(nums[0] == target) return 0; int left = 0; int right = nums.length - 1; while(left \u0026lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; if(nums[0] \u0026lt; target){ if(nums[mid] \u0026lt; target \u0026amp;\u0026amp; nums[mid] \u0026gt;= nums[0]) left = mid + 1; else right = mid - 1; }else if(nums[0] \u0026gt; target){ if(nums[mid] \u0026gt; target \u0026amp;\u0026amp; nums[mid] \u0026lt; nums[0]) right = mid - 1; else left = mid + 1; } } return -1; } }  Solution 2  以上解法思路过于繁琐，可以参考以下方式思考：  mid所处的位置只能为以下两种情况      对于这两种情况我们都用nums[mid]的值与nums[start]或者nums[end]其中的一个配合来判断target所处的区间，进而判断left挪动还是right挪动 代码的整体框架还是Binary Search的方法    class Solution { //time O(logN) || space O(1) public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left \u0026lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if(nums[mid] \u0026gt;= nums[left]){ if(target \u0026lt; nums[mid] \u0026amp;\u0026amp; target \u0026gt;= nums[left]) right = mid - 1; else left = mid + 1; }else{ if(target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) left = mid + 1; else right = mid - 1; } } return -1; } }  ","id":0,"section":"posts","summary":"33.Search in Rotated Sorted Array You are given an integer array nums sorted in ascending order, and an integer target. Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). If target is found in the array return its index, otherwise, return -1. Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3","tags":["algorithm","LinkedList"],"title":"Leetcode 33. Search in Rotated Sorted Array","uri":"https://marekzhang.github.io/2020/10/33.-search-in-rotated-sorted-array/","year":"2020"},{"content":"CSAPP Data Lab Solution less or euqal than  isLessOrEqual - if x \u0026lt;= y then return 1, else return 0\nExample: isLessOrEqual(4,5) = 1.\nLegal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt;\nMax ops: 24\nRating: 3\n  判断一个数是否less or equal than 另一个数可以使用 -x + y 判断结果的符号位是否为0即可(可以涵盖x == y的情况) 但是涉及到加减运算就要考虑sign bit overflow的情况。 $-2^{w-1} \\leq x, y \\leq 2^{w-1}-1$ 如果同符号的两个数做减法一定不会出现越界的情况。而不同符号做减法则大概率出现越界的情况。(位运算得到了与我们期待值不符的值一定是我们期待的结果越界了) 上述分析我们可以把问题拆分为两部分判断  如果是同符号则判断~x+1+y的符号位是否为0 如果是不同符号的情况，我们则要屏蔽掉~x+1+y得到的结果，单纯以符号位判断结果    int isLessOrEqual(int x, int y) { /* 1.如果符号位相同判断 ～x+1+y符号位是否为0； 2.如果符号位不同则以符号位判断大小 */ int res = ~x + 1 + y; // y - x 期待结果为正数或者0 两种情况符号位为都0 int signX = x \u0026gt;\u0026gt; 31; int signY = y \u0026gt;\u0026gt; 31; //符号相同不会出现溢出的情况，结果一定在[-2^(w-1), 2^(w-1)-1]内。此时只需要判断y - x符号位是否为0即可 res = (!(res \u0026gt;\u0026gt; 31)) \u0026amp; (~(signX^signY));// 如果符号位不同 \u0026amp;(~(signX^signY))会把res结果屏蔽掉 //符号位不同的情况下只需要看x的符号位是否为0即可 int signRes = (signX ^ signY)\u0026amp;(!~signX); return res| signRes; }  logicalNeg  logicalNeg - implement the ! operator, using all of\nthe legal operators except !\nExamples: logicalNeg(3) = 0, logicalNeg(0) = 1\nLegal ops: ~ \u0026amp; ^ | + \u0026laquo; \u0026raquo;\nMax ops: 12\nRating: 4\n  实现逻辑！  int x只要bit位上存在1取!值即为0，所以只保留住1个1就可以代表整个数值 x\u0026amp;(~x+1)可以保留最右一位1(Tmin也适用)；对于0来说 x\u0026amp;(~x+1) 仍然是0 保留最右位1后对整个数再取反加1，非0的数一定不会出现最高位进位的现象，而~0的最高位一定会进位 将数值\u0026raquo;31判断最高位的值即可    int logicalNeg(int x) { /*只保留右侧第一个1； 取反+1； 取最高位的符号*/ x = x \u0026amp; (~x + 1); x = ~x + 1; x = ~x \u0026gt;\u0026gt; 31 \u0026amp; 0x01; return x; }  ","id":1,"section":"posts","summary":"CSAPP Data Lab Solution less or euqal than isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; Max ops: 24 Rating: 3 判断一个数是否less or equal than 另一个数可以使用 -x + y 判断结果的符","tags":["csapp"],"title":"CSAPP Data Lab","uri":"https://marekzhang.github.io/2020/10/datalab/","year":"2020"},{"content":"IEEE 745  在IEEE745统一浮点数表示方法之前，不同的计算机采用了不同的浮点数表示方法。\n Floating-Point representation  The IEEE floating-point standard represents a number in a form $V = (−1)^s × M × 2^E$ 如图s为0或者1，作为符号位; exp用来计算E 位数为 1)8bit\u0026ndash;32位浮点数 2)11bit\u0026ndash;64位浮点数; frac用来计算M 位数为 1)23bit\u0026ndash;32位浮点数 2)52bit\u0026ndash;64位浮点数  不同的binary bit形式能够表示三种浮点数：  Normailized (exp 部分不全为0 || 不全为1)  $E = e - bias$ e为exp部分表示的unsgined数的值，$bias=2^(k-1) - 1$ k为exp部分的位数(8\u0026ndash;32位浮点数， 11\u0026ndash;64位浮点数) $M = [1.f_{n-1}, f_{n-2}, f_{n-3}\u0026hellip; f_0]$ fn-1, fn-2表示的是 frac 部分每一个bit上的值(0或者1) $f = f_{n-1} * 2^{-1} + f_{n-2} * 2^{-2} + \u0026hellip; + f_0 * 2^{-n}$ and $0 \\leq f \u0026lt; 1$   Denormalized (exp 部分全为0)  $E = 1 - bias$ $M = [0.f_{n-1}, f_{n-2}, f_{n-3}\u0026hellip; f_0]$ 此时M没有leading 1 $0 \\leq M \u0026lt; 1$ denormalized 可以表示0和非常接近0的小数(E为一个绝对值很大的负数)   Special Value (exp 部分全为1)  如果frac部分全为0，s为0表示$+ \\infty$ 如果frac部分全为0，s为1表示$- \\infty$ 如果frac部分不为0，则表示NAN “not a number” (除0)       about IEEE 745  为什么用unsigned值来解码exp部分:这是为了浮点数大小比较的方便。使用unsigend值，如果符号位为0，只需要按位比较就可得到比较结果。如果用signed值表示exp部分的话，考虑exp使用4bit,这样的话1000代表-8，0111代表7，$2^{7} \u0026gt; 2^{-8}$但是$0111 \u0026lt; 1000$这样大小比较的时候就需要即考虑frac部分又考虑exp部分。即使s符号位为1使用unsgined解码exp部分，只需要将除符号位以外的bit大小比较的结果取反就可以了 为什么使用bias: 因为使用了unsgined解码exp部分，需要将exp所取的unsgined值的区间做偏移，这样既可以表示一个小数点后位数很多的数(当E是一个绝对值很大的负数)，也可以表示一个绝对值很大的数(当E是一个很大的正数) 为什么denormalized情况下$E = 1-bias$而不是$E = -bias$: 这是为了denormalized与normalized的边界点能够平滑过渡。denormalized跨到normalized的第一个值的exp部分一定是00..001,$E = e - bias = 1 - bias$  ","id":2,"section":"posts","summary":"IEEE 745 在IEEE745统一浮点数表示方法之前，不同的计算机采用了不同的浮点数表示方法。 Floating-Point representation The IEEE floating-point standard represents a number in a form $V = (−1)^s × M × 2^E$ 如图s为","tags":["csapp"],"title":"IEEE 745 Floating-Point representation","uri":"https://marekzhang.github.io/2020/10/float-number/","year":"2020"},{"content":"Java split()  str.split(String regx, int limit)  最多匹配limit-1次，返回的是以regx结尾的substring刨除regx部分，最多匹配limit-1次。如果limit是负数则匹配unlimited次。如果limit为0 则与str.split(String regx)相同，会去掉末尾的空字符串。 The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.\n  str.split(String regx)  Java StringBuilder insert(int offset, char c) String s = \u0026quot;abcdef\u0026quot;; char[] chars = s.toCharArray(); StringBuilder sb = new StringBuilder(); for (char aChar : chars) { //将字符插入到sb idx为0的位置 sb.insert(0,aChar); } //outcome fedcba  Leetcode 394. Decode String  Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won\u0026rsquo;t be input like 3a or 2[4].\nExample 1: Input: s = \u0026ldquo;3[a]2[bc]\u0026rdquo; Output: \u0026ldquo;aaabcbc\u0026rdquo;\nExample 2:\nInput: s = \u0026ldquo;3[a2[c]]\u0026rdquo; Output: \u0026ldquo;accaccacc\u0026rdquo;\nExample 3:\nInput: s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo; Output: \u0026ldquo;abcabccdcdcdef\u0026rdquo;\nExample 4:\nInput: s = \u0026ldquo;abc3[cd]xyz\u0026rdquo; Output: \u0026ldquo;abccdcdcdxyz\u0026rdquo;\n  Solution  同 leetcode 71. Simplify Path 可以直到遇到‘[’再进行decoding，其他情况向stack中填入值 注意取出k值时有可能stack为空，要确认!empty()的情况下再进行取值操作    class Solution { public String decodeString(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; s.length(); i++){ if(s.charAt(i) == ']'){ //decoding List\u0026lt;Character\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while(stack.peek()!='[') list.add(0, stack.pop()); //remove '[' stack.pop(); int k = 0; int base = 1; while(!stack.isEmpty() \u0026amp;\u0026amp; Character.isDigit(stack.peek())){ k = (stack.pop() - '0') * base + k; base *= 10; } while(k \u0026gt; 0){ for(Character c : list) stack.push(c); k--; } }else{ stack.push(s.charAt(i)); } } char[] charArr = new char[stack.size()]; for(int i = charArr.length - 1; i \u0026gt;= 0; i--) charArr[i] = stack.pop(); return new String(charArr); } }  ","id":3,"section":"posts","summary":"Java split() str.split(String regx, int limit) 最多匹配limit-1次，返回的是以regx结尾的substring刨除regx部分，最多匹配limit-1次。如果limit是","tags":["algorithm","Stack","Queue","String"],"title":"Stacks and Queues","uri":"https://marekzhang.github.io/2020/10/stackandqueue/","year":"2020"},{"content":"Bitwise operations  | OR \u0026amp; AND ^ XOR ~ Bitwise Complement: it makes every 0 to 1, and every 1 to 0. right shift \u0026gt;\u0026gt; left shift \u0026lt;\u0026lt; e.g. x = 00111011; x \u0026gt;\u0026gt; 2; x = 00001110 -n = ~n + 1  Common use  a^b^b = a 0^a = a^0 = a a^a = 0 N\u0026amp;(-N) merely keeps the rightmost 1 bit (equals N \u0026amp; (~N + 1)) N\u0026amp;(N - 1) remove the rightmost 1 The \u0026gt;\u0026gt;\u0026gt; operator is the unsigned right bit-shift operator (no matter the leftmost bit is 1 or 0, automatically add 0 to the left)  Java operator precedence leetcode problems  Single Number II  Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nInput: [2,2,3,2] Output: 3 Input: [0,1,0,1,0,1,99] Output: 99\n  Solution  将array中所有数值按位加合，与3做余数计算，得到的结果必定是0或者1 按位与0做XOR计算得出single number    class Solution { public int singleNumber(int[] nums) { int res = 0; //int has 32 bits in Java for(int i = 0; i \u0026lt; 32; i++){ int sum = 0; for(int j = 0; j \u0026lt; nums.length; j++){ //count number of '1' at each position sum += nums[j] \u0026gt;\u0026gt; i \u0026amp; 1; } // the result of sum % 3 is 0 or 1 res ^= (sum % 3) \u0026lt;\u0026lt; i; } return res; } }   Counting Bits  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1\u0026rsquo;s in their binary representation and return them as an array.\nExample 1:\nInput: 2 Output: [0,1,1]\nExample 2:\nInput: 5 Output: [0,1,1,2,1,2]\nFollow up:\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\nSpace complexity should be O(n).\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.\n  Solution  对于每一个 0 \u0026lt;= i \u0026lt;= nums, 移除最右边的1所得到的十进制的值的hamming weight + 1 即当前i值的hamming weight    class Solution { //dp time complexity O(n) | space complexity O(1) public int[] countBits(int num) { //res[i] represents the popcount(hamming weight) of i int[] res = new int[num + 1]; for(int i = 1; i \u0026lt;= num; i++) //remove the rightmost 1 res[i] = res[i\u0026amp;(i-1)] + 1; return res; } }   Reverse Bits  Reverse bits of a given 32 bits unsigned integer.\nExample 1:\nInput: 00000010100101000001111010011100 Output: 00111001011110000010100101000000\nExample 2:\nInput: 11111111111111111111111111111101 Output: 10111111111111111111111111111111\n public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { int pos = 31; int res = 0; while(n != 0){ //precedence of += is lower than \u0026amp; and \u0026lt;\u0026lt; res += (n \u0026amp; 1) \u0026lt;\u0026lt; pos; n =\u0026gt;\u0026gt;\u0026gt; 1; pos --; } return res; } }   Bitwise AND of Numbers Range  Given a range [m, n] where 0 \u0026lt;= m \u0026lt;= n \u0026lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: [5,7] Output: 4\nExample 2:\nInput: [0,1] Output: 0\n  solution  找到 m 和 n的common prefix    class Solution { public int rangeBitwiseAnd(int m, int n) { int count = 0; while(m != 0){ if(m == n) break; m \u0026gt;\u0026gt;= 1; n \u0026gt;\u0026gt;= 1; count ++; } return m \u0026lt;\u0026lt; count; } }  ","id":4,"section":"posts","summary":"Bitwise operations | OR \u0026amp; AND ^ XOR ~ Bitwise Complement: it makes every 0 to 1, and every 1 to 0. right shift \u0026gt;\u0026gt; left shift \u0026lt;\u0026lt; e.g. x = 00111011; x \u0026gt;\u0026gt; 2; x = 00001110 -n = ~n + 1 Common use a^b^b = a 0^a = a^0 = a a^a = 0 N\u0026amp;(-N) merely keeps the rightmost 1 bit (equals N \u0026amp; (~N + 1)) N\u0026amp;(N","tags":["algorithm","bitwise"],"title":"Bitwise operations","uri":"https://marekzhang.github.io/2020/10/bitwise/","year":"2020"},{"content":"Description  138. Copy List with Random Pointer\nA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\nReturn a deep copy of the list.\nThe Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.  Solution  Deep copy 不能简单遍历原linkedlist, 对next和random所指向的node进行new Node(node.val)操作，要考虑不同地址的node有可能具有相同的val值 使用HashMap，遍历原LinkedList, 列表中每一个结点做为key以当前遍历结点的val值创建与之对应的新结点并存为value 重新遍历原LinkedList,并从Map中取出简直对来进行next和random指针对赋值操作  class Solution { public Node copyRandomList(Node head) { if(head == null) return null; Map\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Node cur = head; while(cur != null){ map.put(cur, new Node(cur.val)); cur = cur.next; } Node dummyHead = new Node(-1); Node curCopy = dummyHead; cur = head; while(cur != null){ curCopy.next = map.get(cur); curCopy.next.random = map.get(cur.random); cur = cur.next; curCopy = curCopy.next; } return dummyHead.next; } }  ","id":5,"section":"posts","summary":"Description 138. Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index:","tags":["algorithm","LinkedList"],"title":"Leetcode 138 Copy List with Random Pointer","uri":"https://marekzhang.github.io/2020/09/138.-copy-list-with-random-pointer/","year":"2020"},{"content":"Description  142. Linked List Cycle II\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally,\npos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nNotice that you should not modify the linked list.\nFollow up:\nCan you solve it using O(1) (i.e. constant) memory?  Solution  使用fast slow pointers，如果两个指针不能相遇 return null 如果两个指针相遇，相遇的位置为 C % F, C为环的结点个数，F为head到intersection point的结点个数 相遇后slow pointer退回到起始点，fast移动到下一个结点。之后fast slow pointers每次移动一个位置，两个指针再次相遇的位置即为intersection point  public class Solution { //time complexity O(n) || space complexity O(1) public ListNode detectCycle(ListNode head) { if(head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head.next; while(fast != null \u0026amp;\u0026amp; fast.next != null){ if(fast == slow){ slow = head; fast = fast.next; while(fast != slow){ fast = fast.next; slow = slow.next; } return fast; } fast = fast.next.next; slow = slow.next; } return null; } }  ","id":6,"section":"posts","summary":"Description 142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note","tags":["algorithm","LinkedList"],"title":"Leetcode 142 Linked List Cycle II","uri":"https://marekzhang.github.io/2020/09/linked-list-cycle-ii/","year":"2020"},{"content":"Description  92. Reverse Linked List II\nReverse a linked list from position m to n. Do it in one-pass.\nNote: 1 ≤ m ≤ n ≤ length of list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL\n Solution  需要使用DummyHead，因为反转的起始点可能是第一个元素 使用双指针确定反转的区间，找到idx m 前一个元素和 idx n后一个元素 反转LinkedList可以将nex指针初始值赋为cur，这样每次反转之前先挪动nex到下一个位置，就不用考虑cur为null，移动nex所产生的NullPointerException了  class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if(m == n) return head; ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode slow = dummyHead; ListNode fast = dummyHead; //find the prev position of m and nex position of n for(int i = 0; i \u0026lt;= n - m + 1; i++ ) fast = fast.next; for(int i = 1; i \u0026lt; m; i++){ slow = slow.next; fast = fast.next; } ListNode cur = slow.next; ListNode nex = cur; ListNode prev = fast; while(cur != fast){ nex = cur.next; cur.next = prev; prev = cur; cur = nex; } slow.next = prev; return dummyHead.next; } }  ","id":7,"section":"posts","summary":"Description 92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL Solution 需要使用DummyHead，因为反转的起始点可能是第一个元素","tags":["algorithm","LinkedList"],"title":"Leetcode 92. Reverse Linked List II","uri":"https://marekzhang.github.io/2020/09/reverse-linked-list-ii/","year":"2020"},{"content":"Generic Method  如果可以使用泛型方法来替代整个类的泛型化就应该使用泛型方法 static方法无法访问泛型类的类型参数，所有static方法需要使用泛型能力就必须称为泛型方法  public class GenericMethods{ public \u0026lt;T\u0026gt; void f(T x){ System.out.println(x.getClass().getName()); } }   使用泛型方法时不必知名参数类型，因为编译器会找出具体类型 \u0026ndash; type argument inference\n Generic Type and Wildcard \u0026lt;?\u0026gt;  用来声明一个泛型方法或者泛型类。 通配符\u0026lt;?\u0026gt; 使用泛型类或者泛型方法  Type Erasure 考虑下面的情况,返回的结果为true。\npublic class ErasedTypeEquivalence{ public static void main(String[] args){ Class c1 = new ArrayList\u0026lt;String\u0026gt;().getClass(); Class c2 = new ArrayList\u0026lt;Integer\u0026gt;().getClass(); System.out.println(c1 == c2); //true } }   在泛型代码内部，无法获得任何有关泛型类型参数类型的信息\nMap\u0026lt;Long, Double\u0026gt; p = new HashMap\u0026lt;\u0026gt;(); System.out.println(p.getClass().getTypeParameters); //[K, V]    如下代码不能编译\npublic class HasF { public void f() { System.out.println(\u0026quot;HasF.f()\u0026quot;); } } class Manipulator\u0026lt;T\u0026gt; { private T obj; public Manipulator (T x) { obj = x; } public void manipulate() { obj.f(); } //compilation error } public class Manipulation { public static void main(String[] args) { HasF hf = new HasF(); Manipulator\u0026lt;HasF\u0026gt; manipulator = new Manipulator\u0026lt;\u0026gt;(); manipulator.manipulate(); } }  由于擦除机制，Java编译器无法将manipulate()方法在obj上调用f()与HasF拥有f()这一事实映射起来\n  修改Manipulator类为,泛型擦除会将类擦除到第一边界HasF\nclass Manipulator\u0026lt;T extends HasF\u0026gt;  泛型擦除机制的引入是为了兼容Java SE5之前的代码\n ","id":8,"section":"posts","summary":"Generic Method 如果可以使用泛型方法来替代整个类的泛型化就应该使用泛型方法 static方法无法访问泛型类的类型参数，所有static方法需要使用泛型能力","tags":["Java"],"title":"Java Generics","uri":"https://marekzhang.github.io/2020/09/java-generics/","year":"2020"},{"content":"ArrayList  public E remove(int index)  public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }  remove 移除index位置的元素: 首先计算index后面有多少个元素（numMoved），如果元素个数多于1个，使用arrayCopy将index后面所有元素整体向前移动一位\n","id":9,"section":"posts","summary":"ArrayList public E remove(int index) public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } remove 移除index位置的元素: 首先计算index","tags":["Reading Source Code"],"title":"ArrayList Source Code","uri":"https://marekzhang.github.io/2020/09/arraylist/","year":"2020"},{"content":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到新订单的提醒。既然是发送即时通知，使用Web Socket是一个比较好的解决方案\n  首先引入Maven Dependency\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;    配置一个ServerEndpointExporter 这一步很关键。通常情况下Tomcat会主动使用ServletContainerInitializer扫描带有@ServerEndpoint注解的类，但是Spring-Boot这种内嵌web container的框架并不会执行这一步。如果忽略掉这一步配置就会是无尽的404\u0026hellip;\n@Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } }    后台订单页面引入Web Socket js部分。首先判断当前浏览器是否支持Web Socket，之后对onopen(web socekt建立链接), onclose(断开web socket), onerror(web socket链接错误), onmessage(web socket接收到新信息) 以及onbeforunload(页面重新加载前对操作)进行设置。\nvar webSocket = null; if('WebSocket' in window){ webSocket = new WebSocket('ws://markzhang.natapp1.cc/sell/webSocket'); }else{ alert(\u0026quot;current browser does not support web socket\u0026quot;); } webSocket.onopen = function(event){ console.log(\u0026quot;connection set up\u0026quot;); } webSocket.onclose = function(event){ console.log(\u0026quot;web socket disconnected\u0026quot;); }; webSocket.onerror = function(event){ alert(\u0026quot;web socket connection error\u0026quot;); }; webSocket.onmessage = function(event){ console.log(\u0026quot;new message received: \u0026quot; + event.data); $('#orderAlert').modal('show'); document.getElementById('altertAudio').play(); $('#orderDetail').on(\u0026quot;click\u0026quot;, function(){ location.href=\u0026quot;/sell/vendor/order/detail?orderId=\u0026quot;+event.data; }); }; window.onbeforeunload = function(event){ webSocket.close(); };    后台中@ServerEndpoint用来设置web socket 链接的地址。同样对onOpen, onClose, onMessage事件设置响应的程序。这里后端的@onMessage部分不要与前端页面的webSocket.onmessage搞混。@onMessage是前端页面向后端发送信息后端的响应。而webSocket.onmessage是后台有新下单事件发生，后台通过broadcast方法向前端页面发送信息后前端作出的反应。\n  @Component @Slf4j @ServerEndpoint(\u0026quot;/webSocket\u0026quot;) public class WebSocket { private Session session; /** * thread safe set */ private static Set\u0026lt;WebSocket\u0026gt; listeners = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); @OnOpen public void onOpen(Session session) { this.session = session; listeners.add(this); log.info(\u0026quot;[web socket message] set up a connection, number of connections: {}\u0026quot;, listeners.size()); } @OnClose public void onClose(Session session) { listeners.remove(this); log.info(\u0026quot;[web socket message] close a connection, number of connections: {}\u0026quot;, listeners.size()); } /** * server side receive message from the client side * @param message */ @OnMessage public void onMessage(String message) { log.info(\u0026quot;[web socket message] receive message from the client side={}\u0026quot;, message); } /** * server broadcast message to front end sockets * @param message */ public void broadcast(String message) { for (WebSocket listener : listeners) { log.info(\u0026quot;[web socket message] broadcast message={}\u0026quot;, message); try { listener.session.getBasicRemote().sendText(message); } catch (IOException e) { log.error(\u0026quot;[web socket message] broadcast message error: {}\u0026quot;, e.getMessage()); } } } }  这样接单的前台html就和后端打通了，只需要在service层中，下单之后调用boradcast方法就可以发送即时消息了。 //4. revise the number of stock List\u0026lt;CartDTO\u0026gt; cartDTOS = orderDTO.getOrderDetailList().stream(). map(e -\u0026gt; new CartDTO(e.getProductId(), e.getProductQuantity())).collect(Collectors.toList()); productInfoService.decreaseStock(cartDTOS); //5. send message to web socket webSocket.broadcast(orderDTO.getOrderId());    Presentation ","id":10,"section":"posts","summary":"Description 我在搭建Online-Food-Ordering-System这个项目时，当用户在微信小程序上下单的时候，商家的后台系统要能够第一时间收到","tags":["WebSocket","Java","Spring Boot"],"title":"WebSocket in Spring Boot","uri":"https://marekzhang.github.io/2020/09/websocket-spring-boot/","year":"2020"},{"content":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","id":11,"section":"posts","summary":"Setting config baseurl should be set with https:// not http:// And the url should point to your blog site without the github link. e.g.\nbaseURL: https://xxxx.github.io/  ","tags":["Hugo","Pitfalls"],"title":"Hugo Pitfall","uri":"https://marekzhang.github.io/2020/09/hugo-pitfalls/","year":"2020"},{"content":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存和订单部分数据，在高并发的场景下就会产生超卖的问题。\npublic void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Solution  最简单的解决办法是在函数上加synchronize关键字。但会带来几个问题：  运行时间慢：synchronize本质上把线程推入到一个队列中，按照单线程的逻辑运行每一个线程 如果系统被做成了cluster，那么还是会有问题。线程在不同node中运行得到的结果还是不一样    public synchronize void orderProductMockDiffUser(String productId) { //1.query product stock, if stockNum == 0 int stockNum = stock.get(productId); if(stockNum == 0) { throw new OrderException(100,\u0026quot;out of stock\u0026quot;); }else { //2.create order with UID orders.put(KeyUtil.getUID(),productId);// may lead to oversold issue //3.reduce the stock stockNum =stockNum-1; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } stock.put(productId,stockNum); } }  Apache ab 压测\n ab -n500 -c100 http://127.0.0.1:8080/sell/skill/order/123456    使用Redis SETNX 和 GETSET两个命令就可以组合出一个简单的distributed lock，用以解决高并发引入的问题\n SETNX Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed.\u0026gt; SETNX is short for \u0026ldquo;SET if Not eXists\u0026rdquo;.\n  GETSET Atomically sets key to value and returns the old value stored at key. Returns an error when key exists but does not hold a string value.\n  线程使用SETNX对资源进行加锁，如果加锁成功则当前线程获得了资源的使用权。(key:当前资源标识 value: 锁的过期时间（解决死锁问题）) 如果加锁失败，有两种情况: 当前系统资源已经被其他线程占用; 上一个线程出现了异常但没有对锁进行释放). 此时应该先用GET方法取出Value值，如果过期则需要使用GETSET方法对Key进行重新设置，如果GETSET方法返回值与过期的VALUE值相同，证明当前线程成功获得了锁，如果不同则证明同一时间有其他线程进行了相同的操作并获得了锁。如果未过期返回false  @Service(\u0026quot;RedisLock\u0026quot;) public class RedisLock { @Autowired StringRedisTemplate stringRedisTemplate; /** * lock * @param key productId * @param value currentTime + timeout * @return */ public boolean lock(String key, String value) { //current thread get the lock if (stringRedisTemplate.opsForValue().setIfAbsent(key, value)) { return true; } //check if the lock is expired String currentValue = stringRedisTemplate.opsForValue().get(key); //lock is expired if (currentValue != null \u0026amp;\u0026amp; currentValue.length() != 0 \u0026amp;\u0026amp; Long.parseLong(currentValue) \u0026lt; System.currentTimeMillis()) { String oldValue = stringRedisTemplate.opsForValue().getAndSet(key, value); //current thread get the lock if (oldValue!=null \u0026amp;\u0026amp; oldValue.length() != 0 \u0026amp;\u0026amp; currentValue.equals(oldValue)) return true; } return false; } /** * unlock * @param key productId */ public void unlock(String key) { String value = stringRedisTemplate.opsForValue().get(key); if (value != null \u0026amp;\u0026amp; value.length() != 0) { stringRedisTemplate.delete(key); } } }    ","id":12,"section":"posts","summary":"Description 对于High Concurrency 的场景通常要考虑线程抢夺资源的问题。比如电商SecKill活动通常容易出现的超卖现象。比如下面这段代码当有多个线程共享了库存","tags":["Java","Redis","Spring Boot"],"title":"Redis distributed lock","uri":"https://marekzhang.github.io/2020/09/redis-distributed-lock/","year":"2020"}],"tags":[{"title":"algorithm","uri":"https://marekzhang.github.io/tags/algorithm/"},{"title":"bitwise","uri":"https://marekzhang.github.io/tags/bitwise/"},{"title":"csapp","uri":"https://marekzhang.github.io/tags/csapp/"},{"title":"Hugo","uri":"https://marekzhang.github.io/tags/hugo/"},{"title":"Java","uri":"https://marekzhang.github.io/tags/java/"},{"title":"LinkedList","uri":"https://marekzhang.github.io/tags/linkedlist/"},{"title":"Pitfalls","uri":"https://marekzhang.github.io/tags/pitfalls/"},{"title":"Queue","uri":"https://marekzhang.github.io/tags/queue/"},{"title":"Reading Source Code","uri":"https://marekzhang.github.io/tags/reading-source-code/"},{"title":"Redis","uri":"https://marekzhang.github.io/tags/redis/"},{"title":"Spring Boot","uri":"https://marekzhang.github.io/tags/spring-boot/"},{"title":"Stack","uri":"https://marekzhang.github.io/tags/stack/"},{"title":"String","uri":"https://marekzhang.github.io/tags/string/"},{"title":"WebSocket","uri":"https://marekzhang.github.io/tags/websocket/"}]}